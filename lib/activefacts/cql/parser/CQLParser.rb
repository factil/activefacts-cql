#
# Autogenerated from a Treetop grammar. Edits may be lost.


#       ActiveFacts CQL Parser.
#       Parse rules relating to high-level CQL definitions and constraints.
#
# Copyright (c) 2009 Clifford Heath. Read the LICENSE file.
#
require 'activefacts/cql/parser/LexicalRules'
require 'activefacts/cql/parser/Language/English'
require 'activefacts/cql/parser/Expressions'
require 'activefacts/cql/parser/Terms'
require 'activefacts/cql/parser/ObjectTypes'
require 'activefacts/cql/parser/ValueTypes'
require 'activefacts/cql/parser/FactTypes'
require 'activefacts/cql/parser/Context'

module ActiveFacts
  module CQL
    module CQL
      include Treetop::Runtime

      def root
        @root ||= :cql_file
      end

      include LexicalRules

      include Expressions

      include Terms

      include ObjectTypes

      include ValueTypes

      include FactTypes

      include Context

      module CqlFile0
        def s
          elements[0]
        end

        def seq
          elements[1]
        end
      end

      module CqlFile1
        def definitions
          seq.elements.map{|e|
              e.value rescue $stderr.puts "Can't call value() on #{e.inspect}"
            }
        end
      end

      def _nt_cql_file
        start_index = index
        if node_cache[:cql_file].has_key?(index)
          cached = node_cache[:cql_file][index]
          if cached
            node_cache[:cql_file][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_definition
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CqlFile0)
          r0.extend(CqlFile1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:cql_file][start_index] = r0

        r0
      end

      module Definition0
        def definition_body
          elements[0]
        end

        def s
          elements[1]
        end
      end

      module Definition1
        def ast
          definition_body.ast
        end

        def body
          definition_body.text_value
        end
      end

      def _nt_definition
        start_index = index
        if node_cache[:definition].has_key?(index)
          cached = node_cache[:definition][index]
          if cached
            node_cache[:definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_definition_body
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Definition0)
          r0.extend(Definition1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:definition][start_index] = r0

        r0
      end

      module DefinitionBody0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end
      end

      module DefinitionBody1
        def ast; nil; end
      end

      def _nt_definition_body
        start_index = index
        if node_cache[:definition_body].has_key?(index)
          cached = node_cache[:definition_body][index]
          if cached
            node_cache[:definition_body][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_vocabulary_definition
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_import_definition
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_prescan
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_constraint
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                r5 = _nt_unit_definition
                if r5
                  r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                  r0 = r5
                else
                  r6 = _nt_object_type
                  if r6
                    r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                    r0 = r6
                  else
                    r7 = _nt_informal_description
                    if r7
                      r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                      r0 = r7
                    else
                      r8 = _nt_query
                      if r8
                        r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                        r0 = r8
                      else
                        i9, s9 = index, []
                        r10 = _nt_s
                        s9 << r10
                        if r10
                          if (match_len = has_terminal?(';', false, index))
                            r11 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\';\'')
                            r11 = nil
                          end
                          s9 << r11
                          if r11
                            r12 = _nt_s
                            s9 << r12
                          end
                        end
                        if s9.last
                          r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                          r9.extend(DefinitionBody0)
                          r9.extend(DefinitionBody1)
                        else
                          @index = i9
                          r9 = nil
                        end
                        if r9
                          r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                          r0 = r9
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end

        node_cache[:definition_body][start_index] = r0

        r0
      end

      def _nt_vocabulary_definition
        start_index = index
        if node_cache[:vocabulary_definition].has_key?(index)
          cached = node_cache[:vocabulary_definition][index]
          if cached
            node_cache[:vocabulary_definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_model_definition
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_transform_definition
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:vocabulary_definition][start_index] = r0

        r0
      end

      module ModelDefinition0
        def s1
          elements[0]
        end

        def S
          elements[2]
        end

        def vocabulary_name
          elements[3]
        end

        def s2
          elements[4]
        end

      end

      module ModelDefinition1
        def ast
          Compiler::Vocabulary.new(vocabulary_name.value, false)
        end
      end

      def _nt_model_definition
        start_index = index
        if node_cache[:model_definition].has_key?(index)
          cached = node_cache[:model_definition][index]
          if cached
            node_cache[:model_definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          i2 = index
          r3 = _nt_model
          if r3
            r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
            r2 = r3
          else
            r4 = _nt_topic
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r2 = r4
            else
              r5 = _nt_vocabulary
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r2 = r5
              else
                @index = i2
                r2 = nil
              end
            end
          end
          s0 << r2
          if r2
            r6 = _nt_S
            s0 << r6
            if r6
              r7 = _nt_vocabulary_name
              s0 << r7
              if r7
                r8 = _nt_s
                s0 << r8
                if r8
                  if (match_len = has_terminal?(';', false, index))
                    r9 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\';\'')
                    r9 = nil
                  end
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ModelDefinition0)
          r0.extend(ModelDefinition1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:model_definition][start_index] = r0

        r0
      end

      module VocabularyName0
        def node_type; :vocabulary; end
      end

      def _nt_vocabulary_name
        start_index = index
        if node_cache[:vocabulary_name].has_key?(index)
          cached = node_cache[:vocabulary_name][index]
          if cached
            node_cache[:vocabulary_name][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_id
        r0.extend(VocabularyName0)
        r0.extend(VocabularyName0)

        node_cache[:vocabulary_name][start_index] = r0

        r0
      end

      module TransformDefinition0
        def s1
          elements[0]
        end

        def transform
          elements[1]
        end

        def S
          elements[2]
        end

        def vocabulary_name
          elements[3]
        end

        def s2
          elements[4]
        end

      end

      module TransformDefinition1
        def ast
          Compiler::Vocabulary.new(vocabulary_name.value, true)
        end
      end

      def _nt_transform_definition
        start_index = index
        if node_cache[:transform_definition].has_key?(index)
          cached = node_cache[:transform_definition][index]
          if cached
            node_cache[:transform_definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_transform
          s0 << r2
          if r2
            r3 = _nt_S
            s0 << r3
            if r3
              r4 = _nt_vocabulary_name
              s0 << r4
              if r4
                r5 = _nt_s
                s0 << r5
                if r5
                  if (match_len = has_terminal?(';', false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('\';\'')
                    r6 = nil
                  end
                  s0 << r6
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(TransformDefinition0)
          r0.extend(TransformDefinition1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:transform_definition][start_index] = r0

        r0
      end

      module ImportDefinition0
        def s
          elements[0]
        end

        def import
          elements[1]
        end

        def i
          elements[2]
        end

        def S
          elements[3]
        end

        def vocabulary_name
          elements[4]
        end

        def alias_list
          elements[5]
        end

      end

      module ImportDefinition1
        def ast
          Compiler::Import.new(
            import.input.parser, vocabulary_name.value, i.empty? ? "topic" : i.value, alias_list.value
          )
        end
      end

      def _nt_import_definition
        start_index = index
        if node_cache[:import_definition].has_key?(index)
          cached = node_cache[:import_definition][index]
          if cached
            node_cache[:import_definition][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_s
        s0 << r1
        if r1
          r2 = _nt_import
          s0 << r2
          if r2
            r4 = _nt_import_role
            if r4
              r3 = r4
            else
              r3 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r3
            if r3
              r5 = _nt_S
              s0 << r5
              if r5
                r6 = _nt_vocabulary_name
                s0 << r6
                if r6
                  r7 = _nt_alias_list
                  s0 << r7
                  if r7
                    if (match_len = has_terminal?(';', false, index))
                      r8 = true
                      @index += match_len
                    else
                      terminal_parse_failure('\';\'')
                      r8 = nil
                    end
                    s0 << r8
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ImportDefinition0)
          r0.extend(ImportDefinition1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:import_definition][start_index] = r0

        r0
      end

      module ImportRole0
        def S
          elements[0]
        end

        def vocabulary_name
          elements[1]
        end
      end

      module ImportRole1
        def value; vocabulary_name.value; end
      end

      def _nt_import_role
        start_index = index
        if node_cache[:import_role].has_key?(index)
          cached = node_cache[:import_role][index]
          if cached
            node_cache[:import_role][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_S
        s0 << r1
        if r1
          r2 = _nt_vocabulary_name
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ImportRole0)
          r0.extend(ImportRole1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:import_role][start_index] = r0

        r0
      end

      module AliasList0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def alias
          elements[3]
        end

        def S1
          elements[4]
        end

        def aliased_from
          elements[5]
        end

        def S2
          elements[6]
        end

        def as
          elements[7]
        end

        def S3
          elements[8]
        end

        def alias_to
          elements[9]
        end

        def s3
          elements[10]
        end
      end

      module AliasList1
        def value
          elements.inject({}){|h, e| h[e.aliased_from.value] = e.alias_to; h }
        end
      end

      def _nt_alias_list
        start_index = index
        if node_cache[:alias_list].has_key?(index)
          cached = node_cache[:alias_list][index]
          if cached
            node_cache[:alias_list][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          i1, s1 = index, []
          r2 = _nt_s
          s1 << r2
          if r2
            if (match_len = has_terminal?(',', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\',\'')
              r3 = nil
            end
            s1 << r3
            if r3
              r4 = _nt_s
              s1 << r4
              if r4
                r5 = _nt_alias
                s1 << r5
                if r5
                  r6 = _nt_S
                  s1 << r6
                  if r6
                    r7 = _nt_alias_term
                    s1 << r7
                    if r7
                      r8 = _nt_S
                      s1 << r8
                      if r8
                        r9 = _nt_as
                        s1 << r9
                        if r9
                          r10 = _nt_S
                          s1 << r10
                          if r10
                            r11 = _nt_alias_term
                            s1 << r11
                            if r11
                              r12 = _nt_s
                              s1 << r12
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if s1.last
            r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
            r1.extend(AliasList0)
          else
            @index = i1
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(AliasList1)
        r0.extend(AliasList1)

        node_cache[:alias_list][start_index] = r0

        r0
      end

      module AliasTerm0
        def node_type; :term; end
      end

      def _nt_alias_term
        start_index = index
        if node_cache[:alias_term].has_key?(index)
          cached = node_cache[:alias_term][index]
          if cached
            node_cache[:alias_term][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_id
        r0.extend(AliasTerm0)
        r0.extend(AliasTerm0)

        node_cache[:alias_term][start_index] = r0

        r0
      end

      module InformalDescription0
        def signifier
          elements[0]
        end

        def S
          elements[1]
        end

        def term
          elements[2]
        end
      end

      module InformalDescription1
        def signifier
          elements[0]
        end

        def S
          elements[1]
        end

        def reading
          elements[2]
        end

        def s
          elements[3]
        end

      end

      module InformalDescription2
      end

      module InformalDescription3
      end

      module InformalDescription4
      end

      module InformalDescription5
        def informally
          elements[0]
        end

        def s1
          elements[1]
        end

        def s2
          elements[3]
        end

        def subject
          elements[4]
        end

        def s3
          elements[5]
        end

        def text
          elements[6]
        end

      end

      module InformalDescription6
        def ast
          kind = subject.signifier.text_value.to_sym
          subject_name = (kind == :each ? subject.term.text_value : subject.reading.text_value)
          phrases = subject.reading.elements.map(&:ast) if kind == :when
          Compiler::InformalDefinition.new(kind, subject_name, phrases, text.text_value)
        end
      end

      def _nt_informal_description
        start_index = index
        if node_cache[:informal_description].has_key?(index)
          cached = node_cache[:informal_description][index]
          if cached
            node_cache[:informal_description][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_informally
        s0 << r1
        if r1
          r2 = _nt_s
          s0 << r2
          if r2
            if (match_len = has_terminal?(',', false, index))
              r3 = true
              @index += match_len
            else
              terminal_parse_failure('\',\'')
              r3 = nil
            end
            s0 << r3
            if r3
              r4 = _nt_s
              s0 << r4
              if r4
                i5 = index
                i6, s6 = index, []
                r7 = _nt_each
                s6 << r7
                if r7
                  r8 = _nt_S
                  s6 << r8
                  if r8
                    r9 = _nt_term
                    s6 << r9
                  end
                end
                if s6.last
                  r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                  r6.extend(InformalDescription0)
                else
                  @index = i6
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  i10, s10 = index, []
                  r11 = _nt_when
                  s10 << r11
                  if r11
                    r12 = _nt_S
                    s10 << r12
                    if r12
                      s13, i13 = [], index
                      loop do
                        r14 = _nt_phrase
                        if r14
                          s13 << r14
                        else
                          break
                        end
                      end
                      if s13.empty?
                        @index = i13
                        r13 = nil
                      else
                        r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                      end
                      s10 << r13
                      if r13
                        r15 = _nt_s
                        s10 << r15
                        if r15
                          if (match_len = has_terminal?(',', false, index))
                            r16 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\',\'')
                            r16 = nil
                          end
                          s10 << r16
                        end
                      end
                    end
                  end
                  if s10.last
                    r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                    r10.extend(InformalDescription1)
                  else
                    @index = i10
                    r10 = nil
                  end
                  if r10
                    r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                    r5 = r10
                  else
                    @index = i5
                    r5 = nil
                  end
                end
                s0 << r5
                if r5
                  r17 = _nt_s
                  s0 << r17
                  if r17
                    s18, i18 = [], index
                    loop do
                      i19, s19 = index, []
                      i20 = index
                      i21 = index
                      i22 = index
                      if index < input_length
                        r23 = true
                        @index += 1
                      else
                        terminal_parse_failure("any character")
                        r23 = nil
                      end
                      if r23
                        @index = i22
                        r22 = nil
                        terminal_parse_failure("any character", true)
                      else
                        @terminal_failures.pop
                        @index = i22
                        r22 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      if r22
                        r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                        r21 = r22
                      else
                        i24, s24 = index, []
                        if (match_len = has_terminal?('.', false, index))
                          r25 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'.\'')
                          r25 = nil
                        end
                        s24 << r25
                        if r25
                          s26, i26 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[ \\t\\r]'] ||= Regexp.new(gr), :regexp, index)
                              r27 = true
                              @index += 1
                            else
                              terminal_parse_failure('[ \\t\\r]')
                              r27 = nil
                            end
                            if r27
                              s26 << r27
                            else
                              break
                            end
                          end
                          r26 = instantiate_node(SyntaxNode,input, i26...index, s26)
                          s24 << r26
                          if r26
                            if (match_len = has_terminal?("\n", false, index))
                              r28 = true
                              @index += match_len
                            else
                              terminal_parse_failure('"\\n"')
                              r28 = nil
                            end
                            s24 << r28
                          end
                        end
                        if s24.last
                          r24 = instantiate_node(SyntaxNode,input, i24...index, s24)
                          r24.extend(InformalDescription2)
                        else
                          @index = i24
                          r24 = nil
                        end
                        if r24
                          r24 = SyntaxNode.new(input, (index-1)...index) if r24 == true
                          r21 = r24
                        else
                          @index = i21
                          r21 = nil
                        end
                      end
                      if r21
                        @index = i20
                        r20 = nil
                        terminal_parse_failure("(any alternative)", true)
                      else
                        @terminal_failures.pop
                        @index = i20
                        r20 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s19 << r20
                      if r20
                        i29 = index
                        r30 = _nt_string
                        if r30
                          r30 = SyntaxNode.new(input, (index-1)...index) if r30 == true
                          r29 = r30
                        else
                          if index < input_length
                            r31 = true
                            @index += 1
                          else
                            terminal_parse_failure("any character")
                            r31 = nil
                          end
                          if r31
                            r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
                            r29 = r31
                          else
                            @index = i29
                            r29 = nil
                          end
                        end
                        s19 << r29
                      end
                      if s19.last
                        r19 = instantiate_node(SyntaxNode,input, i19...index, s19)
                        r19.extend(InformalDescription3)
                      else
                        @index = i19
                        r19 = nil
                      end
                      if r19
                        s18 << r19
                      else
                        break
                      end
                    end
                    r18 = instantiate_node(SyntaxNode,input, i18...index, s18)
                    s0 << r18
                    if r18
                      i32 = index
                      i33 = index
                      if index < input_length
                        r34 = true
                        @index += 1
                      else
                        terminal_parse_failure("any character")
                        r34 = nil
                      end
                      if r34
                        @index = i33
                        r33 = nil
                        terminal_parse_failure("any character", true)
                      else
                        @terminal_failures.pop
                        @index = i33
                        r33 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      if r33
                        r33 = SyntaxNode.new(input, (index-1)...index) if r33 == true
                        r32 = r33
                      else
                        i35, s35 = index, []
                        if (match_len = has_terminal?('.', false, index))
                          r36 = true
                          @index += match_len
                        else
                          terminal_parse_failure('\'.\'')
                          r36 = nil
                        end
                        s35 << r36
                        if r36
                          s37, i37 = [], index
                          loop do
                            if has_terminal?(@regexps[gr = '\A[ \\t\\r]'] ||= Regexp.new(gr), :regexp, index)
                              r38 = true
                              @index += 1
                            else
                              terminal_parse_failure('[ \\t\\r]')
                              r38 = nil
                            end
                            if r38
                              s37 << r38
                            else
                              break
                            end
                          end
                          r37 = instantiate_node(SyntaxNode,input, i37...index, s37)
                          s35 << r37
                          if r37
                            if (match_len = has_terminal?("\n", false, index))
                              r39 = true
                              @index += match_len
                            else
                              terminal_parse_failure('"\\n"')
                              r39 = nil
                            end
                            s35 << r39
                          end
                        end
                        if s35.last
                          r35 = instantiate_node(SyntaxNode,input, i35...index, s35)
                          r35.extend(InformalDescription4)
                        else
                          @index = i35
                          r35 = nil
                        end
                        if r35
                          r35 = SyntaxNode.new(input, (index-1)...index) if r35 == true
                          r32 = r35
                        else
                          @index = i32
                          r32 = nil
                        end
                      end
                      s0 << r32
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(InformalDescription5)
          r0.extend(InformalDescription6)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:informal_description][start_index] = r0

        r0
      end

      def _nt_constraint
        start_index = index
        if node_cache[:constraint].has_key?(index)
          cached = node_cache[:constraint][index]
          if cached
            node_cache[:constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_subset_constraint
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          r2 = _nt_equality_constraint
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
          else
            r3 = _nt_set_constraint
            if r3
              r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
              r0 = r3
            else
              r4 = _nt_presence_constraint
              if r4
                r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
                r0 = r4
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end

        node_cache[:constraint][start_index] = r0

        r0
      end

      module Enforcement0
        def s1
          elements[0]
        end

        def s2
          elements[2]
        end

        def otherwise
          elements[3]
        end

        def s3
          elements[4]
        end

        def action
          elements[5]
        end

        def s4
          elements[6]
        end

        def a
          elements[7]
        end

        def s5
          elements[8]
        end

        def s6
          elements[10]
        end
      end

      module Enforcement1
        def ast; Compiler::Enforcement.new(action.text_value, a.empty? ? nil : a.text_value); end
      end

      module Enforcement2
        def ast; nil; end
      end

      def _nt_enforcement
        start_index = index
        if node_cache[:enforcement].has_key?(index)
          cached = node_cache[:enforcement][index]
          if cached
            node_cache[:enforcement][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        r2 = _nt_s
        s1 << r2
        if r2
          if (match_len = has_terminal?('(', false, index))
            r3 = true
            @index += match_len
          else
            terminal_parse_failure('\'(\'')
            r3 = nil
          end
          s1 << r3
          if r3
            r4 = _nt_s
            s1 << r4
            if r4
              r5 = _nt_otherwise
              s1 << r5
              if r5
                r6 = _nt_s
                s1 << r6
                if r6
                  r7 = _nt_id
                  s1 << r7
                  if r7
                    r8 = _nt_s
                    s1 << r8
                    if r8
                      r10 = _nt_agent
                      if r10
                        r9 = r10
                      else
                        r9 = instantiate_node(SyntaxNode,input, index...index)
                      end
                      s1 << r9
                      if r9
                        r11 = _nt_s
                        s1 << r11
                        if r11
                          if (match_len = has_terminal?(')', false, index))
                            r12 = true
                            @index += match_len
                          else
                            terminal_parse_failure('\')\'')
                            r12 = nil
                          end
                          s1 << r12
                          if r12
                            r13 = _nt_s
                            s1 << r13
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Enforcement0)
          r1.extend(Enforcement1)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          if (match_len = has_terminal?('', false, index))
            r14 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            r14.extend(Enforcement2)
            @index += match_len
          else
            terminal_parse_failure('\'\'')
            r14 = nil
          end
          if r14
            r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
            r0 = r14
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:enforcement][start_index] = r0

        r0
      end

      module PresenceConstraint0
        def ast
          Compiler::PresenceConstraint.new c, enforcement.ast, clauses_ast, role_list_ast, quantifier_ast
        end
      end

      def _nt_presence_constraint
        start_index = index
        if node_cache[:presence_constraint].has_key?(index)
          cached = node_cache[:presence_constraint][index]
          if cached
            node_cache[:presence_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_each_occurs_in_clauses
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(PresenceConstraint0)
          r0.extend(PresenceConstraint0)
        else
          r2 = _nt_either_or
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(PresenceConstraint0)
            r0.extend(PresenceConstraint0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:presence_constraint][start_index] = r0

        r0
      end

      module SetConstraint0
        def ast
          Compiler::SetExclusionConstraint.new c, enforcement.ast, clauses_ast, role_list_ast, quantifier_ast
        end
      end

      def _nt_set_constraint
        start_index = index
        if node_cache[:set_constraint].has_key?(index)
          cached = node_cache[:set_constraint][index]
          if cached
            node_cache[:set_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_for_each_how_many
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(SetConstraint0)
          r0.extend(SetConstraint0)
        else
          r2 = _nt_either_or_not_both
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(SetConstraint0)
            r0.extend(SetConstraint0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:set_constraint][start_index] = r0

        r0
      end

      module SubsetConstraint0
        def ast
          Compiler::SubsetConstraint.new c, enforcement.ast, [clauses.ast, r2.ast]
        end
      end

      def _nt_subset_constraint
        start_index = index
        if node_cache[:subset_constraint].has_key?(index)
          cached = node_cache[:subset_constraint][index]
          if cached
            node_cache[:subset_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        r1 = _nt_a_only_if_b
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
          r0.extend(SubsetConstraint0)
          r0.extend(SubsetConstraint0)
        else
          r2 = _nt_if_b_then_a
          if r2
            r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
            r0 = r2
            r0.extend(SubsetConstraint0)
            r0.extend(SubsetConstraint0)
          else
            @index = i0
            r0 = nil
          end
        end

        node_cache[:subset_constraint][start_index] = r0

        r0
      end

      module EqualityConstraint0
        def ast
          all_clauses = [clauses.ast, *tail.elements.map{|e| e.clauses.ast }]
          Compiler::SetEqualityConstraint.new c, enforcement.ast, all_clauses
        end
      end

      def _nt_equality_constraint
        start_index = index
        if node_cache[:equality_constraint].has_key?(index)
          cached = node_cache[:equality_constraint][index]
          if cached
            node_cache[:equality_constraint][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_if_and_only_if
        r0.extend(EqualityConstraint0)
        r0.extend(EqualityConstraint0)

        node_cache[:equality_constraint][start_index] = r0

        r0
      end

    end

    class CQLParser < Treetop::Runtime::CompiledParser
      include CQL
    end

  end
end
